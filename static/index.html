<!DOCTYPE html>
<html lang="en">

<script src="/resources/jquery.min.js"></script>
<script src="/resources/jquery-ui.min.js"></script>
<link rel="stylesheet" href="/resources/jquery-ui.css">


<head>
    <meta charset="UTF-8">
    <title>Log Viewer</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <!-- Dark Mode Toggle Switch -->
    <div id="darkModeToggle">
        <label class="dark-mode-label">
            <span class="label-text">Dark Mode</span>
            <input type="checkbox" id="darkModeCheckbox">
            <span class="slider"></span>
        </label>
    </div>

    <!-- Sidebar -->
    <div id="sidebar">
        <h1>Available Hashes</h1>
        <ul id="hashes"></ul>
    </div>

    <!-- Main Content -->
    <div id="main">
        <div style="display: flex; align-items: center;">
            <h2 style="margin-right: 10px;">Log Levels</h2>
            <div class="separator"></div>
            <div id="levels">
                <span class="badge INFO selected" data-level="INFO">INFO</span>
                <span class="badge WARN selected" data-level="WARN">WARN</span>
                <span class="badge ERROR selected" data-level="ERROR">ERROR</span>
                <span class="badge DEBUG selected" data-level="DEBUG">DEBUG</span>
            </div>
        </div>

        <div id="utilityContainer">
            <div id="timeInputs">
                <div>
                    <label for="startTime">Start Time:</label>
                    <input type="datetime-local" id="startTime" name="startTime">
                </div>
                <div>
                    <label for="endTime">End Time:</label>
                    <input type="datetime-local" id="endTime" name="endTime">
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div id="utilityContainer">
            <div style="display: flex; align-items: center; flex-wrap: wrap; gap: 10px;">
                <button id="dumpButton">Download Visible Logs</button>
                <button id="copyButton">Copy Visible Logs</button>
                <button id="deleteSelectedButton" class="danger-button">Delete Selected Hash Logs</button>
                <button id="deleteTimeRangeButton" class="danger-button">Delete Time Range</button>
                <button id="purgeAllButton" class="danger-button">Purge All Logs</button>
                <label for="logCountInput" style="margin-right: 10px;">Logs to fetch:</label>
                <input type="number" id="logCountInput" value="100" min="1">
            </div>
        </div>

        <!-- Logs Header with Search Bar -->
        <div id="utilityContainer">
            <div style="display: flex; align-items: center;">
                <input type="text" id="searchInput" placeholder="Search logs..." style="height: 1.5em; padding: 0.2em;"/>
            </div>
        </div>


        <table id="logs-table">
            <thead>
                <tr>
                    <th class="hash-column">Hash</th>
                    <th class="timestamp-column">Timestamp</th>
                    <th class="level-column">Level</th>
                    <th>Message</th>
                </tr>
            </thead>
            <tbody id="logs"></tbody>
        </table>
    </div>

<script>
    // JavaScript code with fixed time handling and delete functionality
    const logsElement = document.getElementById('logs');
    const hashesList = document.getElementById('hashes');
    const dumpButton = document.getElementById('dumpButton');
    const searchInput = document.getElementById('searchInput');
    const copyButton = document.getElementById('copyButton');
    const deleteSelectedButton = document.getElementById('deleteSelectedButton');
    const deleteTimeRangeButton = document.getElementById('deleteTimeRangeButton');
    const purgeAllButton = document.getElementById('purgeAllButton');

    let selectedHashes = new Set();
    let selectedLevels = new Set(['INFO', 'WARN', 'ERROR', 'DEBUG']);
    let hashColors = {};

    function getPastelColor(hashString) {
        let hash = 0;
        for (let i = 0; i < hashString.length; i++) {
            const char = hashString.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }

        const hue = Math.abs(hash % 360);
        const saturation = 65 + (hash % 20);
        const lightness = 55 + (hash % 15);

        return `hsla(${hue}, ${saturation}%, ${lightness}%, 0.9)`;
    }

    function fetchHashes() {
        fetch('/api/hashes')
            .then(response => response.json())
            .then(hashes => {
                hashesList.innerHTML = '';
                hashes.forEach(hash => {
                    if (!hashColors[hash]) {
                        hashColors[hash] = getPastelColor(hash);
                    }

                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span class="hash-badge" style="background-color: ${hashColors[hash]};">&nbsp;</span>
                        <span class="hash-text">${hash}</span>
                    `;

                    if (selectedHashes.has(hash)) {
                        li.classList.add('selected');
                    }

                    li.onclick = () => {
                        toggleHashSelection(hash, li);
                    };
                    hashesList.appendChild(li);
                });
            });
    }

    function toggleHashSelection(hash, element) {
        if (selectedHashes.has(hash)) {
            selectedHashes.delete(hash);
            element.classList.remove('selected');
        } else {
            selectedHashes.add(hash);
            element.classList.add('selected');
        }
        fetchLogs();
    }

    // Set up level filters
    document.querySelectorAll('#levels .badge').forEach(badge => {
        const level = badge.getAttribute('data-level');

        badge.onclick = () => {
            if (selectedLevels.has(level)) {
                selectedLevels.delete(level);
                badge.classList.remove('selected');
            } else {
                selectedLevels.add(level);
                badge.classList.add('selected');
            }
            fetchLogs();
        };
    });

    function formatDateTimeForAPI(dateTimeLocalValue) {
        if (!dateTimeLocalValue) return null;

        // Convert datetime-local to ISO string
        const date = new Date(dateTimeLocalValue);
        return date.toISOString();
    }

    function fetchLogs() {
        if (selectedHashes.size === 0) {
            logsElement.innerHTML = '<tr><td colspan="4">No hashes selected.</td></tr>';
            return;
        }

        const logCount = parseInt(document.getElementById('logCountInput').value) || 100;

        const startTimeInput = $("#startTime").val();
        const endTimeInput = $("#endTime").val();

        const promises = [];
        selectedHashes.forEach(hash => {
            let url = `/api/logs/${hash}?count=${logCount}`;

            // Add time filters if they exist
            if (startTimeInput) {
                const startTime = formatDateTimeForAPI(startTimeInput);
                if (startTime) {
                    url += `&start=${encodeURIComponent(startTime)}`;
                }
            }

            if (endTimeInput) {
                const endTime = formatDateTimeForAPI(endTimeInput);
                if (endTime) {
                    url += `&end=${encodeURIComponent(endTime)}`;
                }
            }

            const promise = fetch(url)
                .then(response => response.json())
                .then(logs => logs)
                .catch(error => {
                    console.error('Error fetching logs for hash', hash, ':', error);
                    return [];
                });
            promises.push(promise);
        });

        Promise.all(promises).then(results => {
            logsElement.innerHTML = '';
            const allLogs = results.flat();

            const searchQuery = searchInput.value.toLowerCase();

            const filteredLogs = allLogs.filter(log =>
                (selectedLevels.size === 0 || selectedLevels.has(log.level)) &&
                (!searchQuery || log.message.toLowerCase().includes(searchQuery))
            );

            // Sort logs by timestamp in descending order (most recent first)
            filteredLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

            filteredLogs.forEach(log => {
                const row = document.createElement('tr');

                const date = new Date(log.timestamp);
                const formattedTimestamp = date.toLocaleString(undefined, {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                });

                row.innerHTML = `
                    <td class="hash-column">
                        <span class="hash-badge-table" style="background-color: ${hashColors[log.hash]};">${log.hash}</span>
                    </td>
                    <td class="timestamp-column">${formattedTimestamp}</td>
                    <td class="level-column">
                        <span class="level-label level-${log.level}">${log.level}</span>
                    </td>
                    <td>${log.message}</td>
                `;
                logsElement.appendChild(row);
            });
        }).catch(error => {
            console.error('Error fetching logs:', error);
            logsElement.innerHTML = '<tr><td colspan="4">Error loading logs. Check console for details.</td></tr>';
        });
    }

    // Copy visible logs to clipboard
    copyButton.onclick = () => {
        const rows = logsElement.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('No logs to copy.');
            return;
        }

        let clipboardContent = 'Hash\tLevel\tTimestamp\tMessage\n';

        rows.forEach(row => {
            const cols = row.querySelectorAll('td');
            const data = [];
            cols.forEach(col => {
                data.push(col.textContent.trim());
            });
            clipboardContent += data.join('\t') + '\n';
        });

        navigator.clipboard.writeText(clipboardContent).then(() => {
            alert('Logs copied to clipboard.');
        }, () => {
            alert('Failed to copy logs to clipboard.');
        });
    };

    // Dump visible logs to a file
    dumpButton.onclick = () => {
        const rows = logsElement.querySelectorAll('tr');
        if (rows.length === 0) {
            alert('No logs to download.');
            return;
        }

        let csvContent = 'Hash,Level,Timestamp,Message\n';

        rows.forEach(row => {
            const cols = row.querySelectorAll('td');
            const data = [];
            cols.forEach(col => data.push('"' + col.innerText.replace(/"/g, '""') + '"'));
            csvContent += data.join(',') + '\n';
        });

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.setAttribute('href', url);
        link.setAttribute('download', 'logs.csv');
        link.style.visibility = 'hidden';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };

    // Delete functionality
    deleteSelectedButton.onclick = async () => {
        if (selectedHashes.size === 0) {
            alert('No hashes selected.');
            return;
        }

        const hashList = Array.from(selectedHashes).join(', ');
        if (!confirm(`Are you sure you want to delete all logs for these hashes?\n\n${hashList}\n\nThis action cannot be undone.`)) {
            return;
        }

        try {
            const promises = Array.from(selectedHashes).map(hash =>
                fetch(`/api/delete_logs/${hash}`, { method: 'DELETE' })
                    .then(response => response.json())
            );

            const results = await Promise.all(promises);

            let successCount = 0;
            let errorCount = 0;

            results.forEach((result, index) => {
                if (result.success) {
                    successCount++;
                } else {
                    errorCount++;
                    console.error('Delete error for hash', Array.from(selectedHashes)[index], ':', result.message);
                }
            });

            if (successCount > 0) {
                alert(`Successfully deleted logs for ${successCount} hash(es).${errorCount > 0 ? ` ${errorCount} failed.` : ''}`);
                // Clear selected hashes and refresh
                selectedHashes.clear();
                fetchHashes();
                fetchLogs();
            } else {
                alert('Failed to delete any logs. Check console for details.');
            }
        } catch (error) {
            console.error('Delete error:', error);
            alert('Error occurred while deleting logs.');
        }
    };

    deleteTimeRangeButton.onclick = async () => {
        const startTimeInput = $("#startTime").val();
        const endTimeInput = $("#endTime").val();

        if (!startTimeInput || !endTimeInput) {
            alert('Please select both start and end times.');
            return;
        }

        const startTime = formatDateTimeForAPI(startTimeInput);
        const endTime = formatDateTimeForAPI(endTimeInput);

        if (!confirm(`Are you sure you want to delete all logs between:\n\n${new Date(startTime).toLocaleString()} and ${new Date(endTime).toLocaleString()}\n\nThis action cannot be undone.`)) {
            return;
        }

        try {
            const response = await fetch('/api/delete_time_range', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    start_time: startTime,
                    end_time: endTime
                })
            });

            const result = await response.json();

            if (result.success) {
                alert(`Successfully deleted ${result.deleted_count} log(s).`);
                fetchHashes();
                fetchLogs();
            } else {
                alert(`Failed to delete logs: ${result.message}`);
            }
        } catch (error) {
            console.error('Delete time range error:', error);
            alert('Error occurred while deleting logs.');
        }
    };

    purgeAllButton.onclick = async () => {
        if (!confirm('Are you sure you want to DELETE ALL LOGS?\n\nThis will permanently remove every log in the database.\n\nThis action cannot be undone.')) {
            return;
        }

        if (!confirm('This is your final warning. ALL LOGS WILL BE PERMANENTLY DELETED.\n\nClick OK to proceed or Cancel to abort.')) {
            return;
        }

        try {
            const response = await fetch('/api/purge_logs', { method: 'POST' });
            const result = await response.json();

            alert(result);
            selectedHashes.clear();
            fetchHashes();
            fetchLogs();
        } catch (error) {
            console.error('Purge error:', error);
            alert('Error occurred while purging logs.');
        }
    };

    // Handle search input
    searchInput.addEventListener('input', () => {
        fetchLogs();
    });

    const darkModeCheckbox = document.getElementById('darkModeCheckbox');
    const bodyElement = document.body;

    // Load dark mode preference from localStorage
    if (localStorage.getItem('darkMode') === 'enabled') {
        bodyElement.classList.add('dark-mode');
        darkModeCheckbox.checked = true;
    }

    darkModeCheckbox.addEventListener('change', () => {
        if (darkModeCheckbox.checked) {
            bodyElement.classList.add('dark-mode');
            localStorage.setItem('darkMode', 'enabled');
        } else {
            bodyElement.classList.remove('dark-mode');
            localStorage.setItem('darkMode', 'disabled');
        }
    });

    // Initialize date inputs
    $(async function () {
        // Fetch logs when date inputs change
        $("#startTime, #endTime").on("change", function () {
            fetchLogs();
        });

        // Initial fetch of logs
        fetchLogs();
    });

    // Initial fetch of hashes
    fetchHashes();

    // Refresh hashes every 3 seconds
    setInterval(fetchHashes, 3000);

    // Refresh logs every 1 second
    setInterval(fetchLogs, 1000);

</script>

</body>
</html>
